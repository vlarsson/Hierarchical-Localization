import numpy as np


def score_line_segment(pts_3d, x1, x2, thr):
    # validate line generated by x1,x2
    v = (x2-x1) / np.linalg.norm(x2-x1)
    score = 0.0
    inl = []
    for k in range(len(pts_3d)):
        r = pts_3d[k]-x1
        r = r - np.dot(v,r) * v
        r = np.linalg.norm(r)**2

        if r < thr:
            score += r
            inl.append(True)
        else:
            score += thr
            inl.append(False)

    return score, inl

def fit_line(pts_3d, thr):
    # Fits a line through 3D points via exhaustive RANSAC
    # Threshold thr is the max 3D distance allowed

    best_score = np.inf
    best_inl = []
    for i in range(len(pts_3d)):
        for j in range(i):
            x1 = pts_3d[i]
            x2 = pts_3d[j]

            if np.linalg.norm(x1-x2) <= 1e-6:
                continue

            score, inl = score_line_segment(pts_3d, x1, x2, thr)
            if score < best_score:
                best_score = score
                best_inl = inl

    # This can happen if we only have 1 point (with duplicates)
    # (which can in turn happen since we do NN depth interpolation)
    if np.sum(best_inl) == 0:
        return None

    # Refit to inliers
    pts_3d_inl = pts_3d[best_inl]
    centroid = pts_3d_inl.mean(axis=0)
    uu,ss,vv = np.linalg.svd(pts_3d_inl - centroid)
    direction = vv[0]

    # Select endpoints by projecting inliers to the line
    # and taking the extreme projections
    alpha = (pts_3d_inl - centroid) @ direction
    x1 = centroid + alpha.min() * direction
    x2 = centroid + alpha.max() * direction

    return np.concatenate([x1, x2])
